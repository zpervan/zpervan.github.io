[{"content":"","date":"17 April 2023","permalink":"/","section":"Digital Sandbox","summary":"","title":"Digital Sandbox"},{"content":"","date":"17 April 2023","permalink":"/tags/frontend/","section":"Tags","summary":"","title":"frontend"},{"content":"","date":"17 April 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"17 April 2023","permalink":"/tags/rust/","section":"Tags","summary":"","title":"rust"},{"content":"","date":"17 April 2023","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"17 April 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"17 April 2023","permalink":"/series/weather-station/","section":"Series","summary":"","title":"Weather station"},{"content":"In today\u0026rsquo;s standards, no project, which includes a data acquisition component, is complete without any proper data visualization, as \u0026ldquo;raw\u0026rdquo; data alone can look like a bunch of random numbers and letters clumped together. There is a variety of technologies and tools to achieve the desired visualization, but I decided to make this a challenge and use Rust to make an OS-agnostic (Windows and Ubuntu) desktop application.\nPrerequisites\u003e Prerequisites # Rust has a lot of powerful low-level tools in its toolbox, with a wide selection of GUI frameworks and interesting (sometimes frustrating) programming concepts and techniques (looking at you, ownership) which allows developers to create more stable and safer applications and this is what sets Rust apart from languages like C++ or Golang.\nOne interesting fact - Linux developers are moving the Linux kernel technology from C to Rust. So, it seems that Rust has really great potential to be a main technology on future projects for developers coming from a low-level technology.\nBut I digress.\nFor this project, I used the Druid GUI framework to create the application with the plotters-druid \u0026ldquo;addon\u0026rdquo; which allows me to create that juicy visualization.\nIf you installed Rust for Windows as suggested, the application should run out-of-the-box by just running a simple cargo command, but Ubuntu needs some special attention by installing additional GTK libraries to make this work properly. The installation steps can be found in the project README file.\nHow does it work?\u003e How does it work? # The application workflow is rather simple, as it can be seen from the picture below. Picture 1 - Simplified application workflow Basically, when the refresh event occurs, asynchronously fetch the weather data, parse the response and visualize it in the application. Preview of the desktop application with 24 hours temperature and humidity data can be seen in the following picture. Picture 2 - GUI In order to visualize new data from the server, the user needs to select a date and hit the â­¯ (refresh) button which will then execute the previously described workflow.\nYou probably noticed that I did not include any error handling functionalities (i.e, server not reachable, error while encoding data, etc.) in the workflow, and it\u0026rsquo;s because I want to have a minimal working application at this stage and verify that the application is following the proposed workflow, but I will consider to add error handling later on as it\u0026rsquo;s a necessary aspect for a robust application.\nIn the end, to run the application, just execute the following command where the main cargo.toml file is located (in this case, root of the application folder)\ncargo run . Server improvements\u003e Server improvements # As mentioned in a previous blog post, the server API will be extended so the server has all needed functionalities to fetch data for specific dates. Therefor, I added three additional routes with unique handlers, which are:\n/get/{date:^[0-9]{8}$} - Fetch the weather data from the specified date /dates - Fetch all unique dates on which the measurement was taken /dates/latest - Fetch the latest (newest) date GetByDate handler\u003e GetByDate handler # Let\u0026rsquo;s have a better look at the getter function which fetches specific date weather data, called GetByDate, as there are quite some things going on under the hood. Firstly, one example of a request to fetch the specific date weather data looks like the following:\nhttp://192.168.1.1:3500/get/20230412 The request URL consists of the server address and port on which it\u0026rsquo;s listening to, followed by the endpoint route in which the last section of the URL is the date query parameter in the format YYYYMMDD. The reason why I chose this format is because MongoDB stores it\u0026rsquo;s datetime information in a similar fashion so it would be more intuitive to read the given \u0026ldquo;raw\u0026rdquo; database data if any reasons occur and to be more consistent with the rest of the system.\nChi (the web framework) allows us to use regular expression, which will be used while sending query requests to the server and define what kind of data will be accepted from the server. The regular expression ^[0-9]{8}$ will only process data that consists entirely of 8 digits (0-9), from the beginning (^) to the end ($) of the string, otherwise it will return a 404 error code as response.\nWhen the GetByDate handler is called, the passed date is converted into a Time data type which allows to do various datetime operations like conversions from one date format to another. Golang also has a great support for MongoDB so fetching data is relatively straightforward. Afterwards, a date filter is created based on the converted date which will then return all weather data which satisfy the given conditions in the filter. In this case, return all data from the first (00:00:00h) until the last (23:59:59h) measurement for the given day.\nFor completeness, the following code snippet shows the filter described above.\ndateFilter := bson.D{{\u0026#34;created_on\u0026#34;, bson.D{ {\u0026#34;$gt\u0026#34;, primitive.NewDateTimeFromTime(parsedDate).Time().AddDate(0, 0, 0)}, {\u0026#34;$lt\u0026#34;, primitive.NewDateTimeFromTime(parsedDate).Time().AddDate(0, 0, 1)}, }}} The bson.D represents a data type in which order of the BSON elements matter, which, in this case, are important as the data should be sorted from oldest to newest. More about the MongoDB data structs can be found here.\n$gt (greater than) and $lt (less than) represent the conditions which must be met in order to retrieve all data for the given date. Someone probably asks \u0026ldquo;Why not use some kind of equal criteria?\u0026rdquo; - I tried, but the $eq (equal) operator would return only a single entry.\nAfter that, the query command is issued with the above given filter criteria, which returns a cursor to the found stream of documents which met the conditions over which we iterate, store each element into a query result buffer ( slice] of the WeatherData struct), and respond back to the caller with the data.\nConclusion\u003e Conclusion # This part of the project was quite of a challenge, mostly because I used new and unfamiliar technologies and frameworks, but it was a lot of fun. Rust and Golang can create great software solutions for any situation and any project, but, in some cases, it\u0026rsquo;s lacking support as those languages are relatively new compared to C++ so you have to use workarounds to get things work as intended.\nAnother thing that I would like to add to this project is a web-based application created with Wasm so we can use it on any platform (mobile or PC), but this is for another time as this has challenges on it\u0026rsquo;s own.\nHope you enjoyed it and thanks for reading!\n","date":"17 April 2023","permalink":"/posts/weatherstation_part4/","section":"Posts","summary":"Measured weather data fetching and visualization created with Rust as a desktop application for Windows and Ubuntu.","title":"Weather station - Data visualization"},{"content":"","date":"17 April 2023","permalink":"/tags/weather-station/","section":"Tags","summary":"","title":"weather-station"},{"content":"","date":"13 April 2023","permalink":"/tags/docker/","section":"Tags","summary":"","title":"docker"},{"content":"","date":"13 April 2023","permalink":"/tags/server/","section":"Tags","summary":"","title":"server"},{"content":"Now, with the measuring station up and running, the backend storing and fetching data, it\u0026rsquo;s time to dockerize stuff! This blog post will explore the benefits of Docker and how it can help us create independent and deployable services.\nYeah, but why?\u003e Yeah, but why? # This is a question which I asked myself when I learned about Docker\u0026rsquo;s existence. This virtualization and \u0026ldquo;spinning containers\u0026rdquo; things seemed odd and redundant to me, but mostly because the majority of my experience was with embedded systems and some scripting. Nowadays, if the place and time is right, I try to dockerize everything that makes sense to do so and create independent, lightweight, and deployable services.\nSome nice things that I experienced with Docker:\nSandboxed environment - Effectively allows to experiment and test things out without affecting the stability of the host environment Reproducibility - Once you have the image set-up, every time you start a container, it will always be the same, no surprises Networking - Docker allows for containers to communicate with each other inside its networking system and connect them even with non-Docker (host) workloads Storage - Want to manage or migrate the data from your database? No problems, Docker volumes will do the trick Orchestration - Run or remove Docker containers on the fly based on your current workload and needs The list of handy features is quite extensive, but the above points is something that I find most useful during development and deployment. Also, one additional thing for which Docker is famous for, and it\u0026rsquo;s used a lot in complex software systems, is the microservice software architecture style.\nThere are alternatives like Podman which will do also the trick, but Docker will be in the focus od this project.\nComponents overview and relations\u003e Components overview and relations # In order to get a better grasp on how things are connected with each other, the following picture shows an overview of all components in the project.\nPicture 1 - Client-server component relations By looking at the picture, a classic architectural pattern emerges - client-server aka the three-tier architecture. The components are organized into the following tiers:\nPresentation tier - data visualization application Application tier - server, measuring station(?) Data tier - database I put a question mark besides the measuring station as, by definition of the application tier, it collects and processes the information from the presentation tier and sends it to the database. As the measuring station is collecting, processing, sending data to the server, and, ultimately, storing it into the database via the server, I assigned it to the application tier, but this is a topic of discussion on its own.\nThe server and database can be services by itself, so I decided to dockerize them for now. The data visualization is currently available as a desktop application but could be also dockerized once the application is built with the Wasm binary which would convert the desktop into a web application, but more on that in a follow-up post.\nDocker files\u003e Docker files # In order to achieve the previously mentioned dockerization, docker files need to be implemented. In this situation, one docker file for the server, and a docker compose file to run all defined services (containers), which are the server and database.\nThe server docker file looks like the following:\n# Image FROM golang:1.20.1 # Define the work directory on the host WORKDIR ./server # Copy the host project folders into the container\u0026#39;s working directory COPY ./server . # Create/update the go.sum file RUN go mod tidy # Build the server binary RUN go build -o server . # Give executable privileges to the `server` binary RUN chmod +x server # Run the backend server CMD [ \u0026#34;./server\u0026#34; ] In simple terms, it\u0026rsquo;s just defining steps what needs to be done in order to run the server executable. One thing to mention here is that Docker offers images on it\u0026rsquo;s hub with ready-to-use containers. In this case, I use the Golang image as the base image, which is running a Ubuntu 22.04 OS with a preinstalled Golang environment, and will include the copied server files into the image itself which looks like the following:\nPicture 2 - Directory layout inside the Docker container In order to run the whole system at once, docker-compose comes to the rescue. To achieve this, a docker-compose.yml file is created which defines all needed services, volumes and network parameters. One example of a database service looks like the following:\nservices: # Service name database: # Image name which will be pulled from the Docker hub image: mongo # Name of the container which will be assigned once run container_name: sdws_database # Restart policy in case of an exit # Example - The server is depending on the database service which has not started yet. # The server will restart until the database service is ready for usage. restart: always # Port exposure - maps the port 27018 to 27017 (default MongoDb port) ports: - \u0026#34;27018:27017\u0026#34; # Contains sensitive information, i.e. database login credentials env_file: .env # Database data volumes: # Where the database will store the data - database_data:/data/db # MongoDB initialization script - ./server/database/mongo-init.js:/docker-entrypoint-initdb.d/mongo-init.js:ro # Allow containers and host to communicate with each other networks: - network Once the services, volumes and networks are properly defined, they be run by executing the following command:\ndocker-compose up -d --build This will run all services in detached mode and will build the images before the starting the images in case there are any new changes.\nDedicated host\u003e Dedicated host # To make this work as standalone services, one approach was to create a dedicated server which, in my case, is an old laptop with Ubuntu Server 22.04.2 running as it has all needed networking functionalities for the server. One important thing to install is Docker, which will be sufficient to run the server. Also, make sure you enable ssh so you can connect from any device within your local network to the server.\nAfter everything is installed properly and the above mentioned docker-compose command is executed, the containers will be only visible within the host machine (localhost) and is not visible on our local network which means that the measuring station will not be able to send request with weather data to the server. To circumvent this situation, enable data traffic via port 3500 inside the host\u0026rsquo;s firewall - more about on opening ports that can be seen here.\nOnce traffic on the port 3500 is enabled, the IP address of the dedicated server must be obtained. One approach is to type in the command ifconfigon the server and search the interface over which you\u0026rsquo;re connected to your local network - in my case it was the ethernet interface. More about that can be found here. Another approach is to open up your router management site and look for the connected devices list which should contain the IP address of the server.\nNOTE Probably there are restart cycles set in your router which will purge the existing IP address list and assign new ones to all your connected devices if DHCP is enabled once the router is restarted. Make sure that the server PC has a static IP address set in the \u0026ldquo;Reserved IP Address\u0026rdquo; section of the DHCP configuration page, otherwise the IP address needs to be obtained every time.* Once all this is set, the server should accept incoming requests via the browser (or any network communication and data transfer tool) and can be pinged. Let\u0026rsquo;s assume that the device address is set to 192.168.1.42, and we know that the communication is taking place via port 3500, just enter the following address into the browser:\nhttp://192.168.1.42:3500/ping An \u0026quot;OK\u0026quot; response should be returned, and with that kind of response the verification process is completed and start to use the server by adding and fetching weather data from the server.\nConclusion\u003e Conclusion # This post covers all about the dockerization process and allowing the server to communicate over the local network with the measuring station. The next blog post will cover the visualization process of the measured data which is as a desktop application written in Rust.\nStay tuned and thanks for reading!\nP.S. Link to the project: https://github.com/zpervan/SuperDuperWeatherStation\n","date":"13 April 2023","permalink":"/posts/weatherstation_part3/","section":"Posts","summary":"Containerization of the backend server and database as standalone services with Docker and setting it up on a dedicated host.","title":"Weather station - Containerization and hosting"},{"content":"","date":"31 March 2023","permalink":"/tags/golang/","section":"Tags","summary":"","title":"golang"},{"content":"As the measuring station is wired up, can connect to the local network via Wi-Fi and obtain weather data, it\u0026rsquo;s time to process and store the data within our server. This article will focus on how to add the data from the measuring station to the server and store the weather information into the database.\nThe full code example will be given at the end of the post.\nNOTE The database setup will be explained in the follow-up post. Technology decisions\u003e Technology decisions # There are numerous possibilities on how to build the server and database, so I ended up with the following:\nGolang for the server - simple, performance-oriented, highly concurrent, built-in network functionalities, lot of community support etc. MongoDB for the database - scalable, document based, NoSQL database which is perfect for handling high traffic and unstructured data (i.e., sensor data) Another option that I was considering for the database was Redis as it\u0026rsquo;s an in-memory data structured database which is perfect for IoT based projects, but this is for another time.\nSystem overview\u003e System overview # For a better understanding on how the system components are related to each other, the picture below shows a simplified architectural overview.\nPicture 1 - System overview The server and database are located on a dedicated host which, in my case, is an old laptop with an installed Ubuntu Server 22.04.2 OS, but any type of hardware that supports any Unix or Windows like operating system will do the trick (i.e., Raspberry Pi).\nBoth, the measuring station and server PC, are connected to the local network. In order to make HTTP requests from the measuring station to the server, the IP address of the server PC needs to be obtained which is vital in order to know where the data should be sent. More about on how to setup the dedicated host and database will be available in the follow-up post of this series.\nThe paths we choose\u0026hellip;\u003e The paths we choose\u0026hellip; # To continue in the spirit of simplicity, there will be three routes (endpoints) in the server which are the following: Each endpoint has appropriately assigned handlers which do the following:\n/ping - Checks whether the server is online and functional /get - Retrieves all the weather data located in the database /add - Adds the weather data into the database If this looks a bit fuzzy to you, here is a refresher about HTTP requests methods.\nIn order to implement the above-mentioned endpoints, there are multiple options in Golang to choose from - the one I went with was the router library Chi as it has a lot of handy networking and router features. Initially, I wanted to go with Gorilla Mux as I have worked with it in the past, but the development stopped so it will be ditched for this project.\nAnyways, the following code snippet contains the setup process of the router router and it\u0026rsquo;s functionalities which are handling the requests.\npackage web import ( \u0026#34;github.com/go-chi/chi/v5\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;server/core\u0026#34; ) type Routes struct { // Necessary dependencies of the app (i.e., logger, session manager, etc.) App *core.Application // Handler functions for each endpoint Handlers *Handler } // Acts as a constructor for our router functionality func NewRouter(app *core.Application) *Routes { // Create a \u0026#34;Routes\u0026#34; object on the heap routes := \u0026amp;Routes{} // Initialize the needed dependencies routes.App = app // Contains all handler functionalities for our server routes.Handlers = NewHandler(app) return routes } func (r *Routes) HandleRequests() *chi.Mux { // Instantiate a new router router := chi.NewRouter() //GET endpoints router.Get(\u0026#34;/ping\u0026#34;, r.Handlers.Ping) router.Get(\u0026#34;/get\u0026#34;, r.Handlers.Get) // POST endpoints router.Post(\u0026#34;/add\u0026#34;, r.Handlers.Add) return router } Also, I plan to implement an additional endpoint which will fetch data between specific dates, but more on that in the future.\nDatabase schema and handlers\u003e Database schema and handlers # The database schema looks like the following:\ndatetime temperature humidity This schema is also reflected in the WeatherData data structure in Go which is used for storing request and creating response data.\n// WeatherData Contains all necessary data in order to retrieve or store weather data type WeatherData struct { Datetime primitive.DateTime `json:\u0026#34;datetime\u0026#34; bson:\u0026#34;datetime\u0026#34;` Temperature string `json:\u0026#34;temperature\u0026#34; bson:\u0026#34;temperature\u0026#34;` Humidity string `json:\u0026#34;humidity\u0026#34; bson:\u0026#34;humidity\u0026#34;` } FYI, the additional tags added besides the structure data members are called struct tags.\nAs we have a simple API interface for now, there is no need to implement all CRUD functionalities for the MongoDB database - only Create and Read. To achieve this, there are dedicated libraries in Golang which is the Mongo Driver package and is a perfect fit for our case. To get a feeling how this looks like, the follow-up code snippet shows the Create functionality:\n// Database Contains all needed functionality and dependencies in order to execute database CRUD operations type Database struct { app *core.Application WeatherData *mongo.Collection } func (db *Database) Create(weatherData *WeatherData) error { weatherData.Datetime = primitive.NewDateTimeFromTime(time.Now()) _, err := db.WeatherData.InsertOne(context.TODO(), weatherData) if err != nil { return err } return nil } The create functionality takes in a WeatherData type of data which is received from the measurement station with accompanying weather data measurements. The Temperature and Humidity (of the passed data) were previously populated in the handler function called Add with the received data. Additionally, the Datetime field is created and assigned inside the above shown database function as MongoDB has some special functions for creating datetime stamps.\nWorking with the server\u003e Working with the server # To better grasp the above-described concepts and ideas, let\u0026rsquo;s have a look of an example workflow in which the weather data is sent to the server.\nPicture 3 - Example workflow of adding new weather data to the database After the measurement is conducted, the ESP01 creates an HTTP POST request in which the measurements are added in JSON form to the POST request payload. The destination URL represents the server endpoint, which is composed of the target address (IP address of the dedicated host in the local network), port number over which the server is communicating, and the actual endpoint name which, in our case, adds the data to the database.\nTo check whether the API and handler functions are working as expected, there are several options to test it. The two that I used during this project:\ncurl - command-line based data transferring tool with URLs, can be used both on Linux and Windows Postman - Popular GUI API platform for building and using APIs One example of adding mocked data into the database with curl, and testing it therefore, looks like the following:\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39;{\u0026#34;temperature\u0026#34;:\u0026#34;21\u0026#34;, \u0026#34;humidity\u0026#34;:\u0026#34;36\u0026#34;}\u0026#39; http://192.168.1.2:3500/add After the request is sent, the log output of the server looks like the following: Conclusion\u003e Conclusion # In this post we covered a lot of topics - from the overall design, how the server code looks like all to how to make HTTP requests. In the next post I will write about how to set up the database, dockerize the whole server and how to run it on a dedicated host.\nFull server example can be found here.\nStay tuned and thanks for reading!\n","date":"31 March 2023","permalink":"/posts/weatherstation_part2/","section":"Posts","summary":"Design and implementation of a backend server, created with Golang and MongoDB, which stores and serves the measured data via REST API.","title":"Weather station - Server and database"},{"content":"","date":"26 March 2023","permalink":"/tags/esp01/","section":"Tags","summary":"","title":"esp01"},{"content":"","date":"26 March 2023","permalink":"/tags/esp8266/","section":"Tags","summary":"","title":"esp8266"},{"content":"As spring is now here, it was time for a new side project. For a long period of time, I wanted to build a small weather station where the data was stored, somewhere, on my local network. The server technology decision was based on something that I have started to learn in recent times and, therefore, wanted to explore it even more.\nThe project itself is (currently) made of two parts:\nMeasuring station - Consists of a microcontroller with and integrated Wi-Fi module, and a sensor for measuring temperature and humidity data Server - Receives the microcontroller weather data and serves it to all connected clients In some point of time in the future, I plan to add some kind data visualization in the form of a desktop or web application, but for now, letâs take the first step by making the backend work properly. This post will focus on how to connect the measuring station itself and show a minimum working code example.\nYou can find the full working code example at the end of the post.\nThe hardware\u003e The hardware # The measuring station consists of three major components:\nESP01 microcontroller with a built-in Wi-Fi module DHT22 temperature and humidity sensor Power supply Both, the microcontroller and sensor, work on 3.3VDC so there are multiple options to provide the needed power. I chose to use the YwRobot 545043 power supply module during the development process for two reasons:\nProvides a stable 3.3VDC with a maximum of 700mA at the output which is more than sufficient Header pins which can snug easily into any larger development board so no additional wiring is needed There are alternatives for making a power supply, like creating a voltage divider or use a voltage regulator like AMS1117 which would be a better option if we wanted to make a small PCB, but this decision is for a later stage of the project as I want to keep it simple and without any need for additional components or designs.\nConnection schema\u003e Connection schema # The wiring diagram is really simple, as you can see in the picture below.\nPicture 1 - Connection schema Besides the above-mentioned components, there is a pullup resistor which is used to have a stable signal voltage value while the ESP01 and DHT22 are exchanging data. When all components are connected together, we get the following: Picture 2 - End result Bringing the hardware to life\u003e Bringing the hardware to life # The proposed software solution is pretty straightforward, which means it\u0026rsquo;s all out-of-the-box solutions. First of all, make sure you have installed the Arduino IDE and added the ESP8266 package. More information on how to setup the Arduino IDE can be seen here.\nTo upload the code to the ESP01 module, I used the Open-Smart USB to ESP01 Adapter which makes the upload process super simple, and you can switch between programming and USB mode which comes handy while debugging or monitoring activities on the ESP01 via serial monitor. One caveat of the USB specified adapter is that you cannot (at least without any modification) hook up any external devices (i.e., sensor) so the debugging or monitoring process can be cumbersome.\nThere are other alternatives of uploading the code to ESP01 like with an Arduino board, but it tends to be messy and error prone, so I suggest USB adapter approach.\nLet\u0026rsquo;s connect\u003e Let\u0026rsquo;s connect # In order to connect to your local Wi-Fi network, the following libraries are needed:\n#include \u0026lt;ESP8266WiFi.h\u0026gt; #include \u0026lt;ESP8266WiFiMulti.h\u0026gt; #include \u0026lt;ESP8266HTTPClient.h\u0026gt; Those libraries will allow the ESP01 to connect and communicate with the server over the local network. The setup code looks like the following:\n/* Environment variables */ #define SSID \u0026#34;YourNetwork\u0026#34; #define PASSWORD \u0026#34;NetworkPassword123\u0026#34; /* Globals */ ESP8266WiFiMulti wifi_multi; void setup() { // Set the ESP01 into \u0026#34;STATION\u0026#34; mode WiFi.mode(WIFI_STA); // Add the Wi-Fi connection data wifi_multi.addAP(SSID, PASSWORD); // Try to connect wl_status_t status = wifi_multi.run(); if(status != WL_CONNECTED) { // Error handling code... } } void loop() { // Server communication and sensor measuring code } One common error, which I also made, was the wrong SSID and PASSWORD of the network, so make sure everything is correct. If the setup was successful, HTTP requests can be sent to the server which means we can send the actual weather data. The HTTP request and response part will be covered in a follow up post of the weather station series.\nWhat\u0026rsquo;s the weather outside?\u003e What\u0026rsquo;s the weather outside? # DHT sensors are, by now, one of the most used sensors in starter or home projects, and therefore have a simple and straightforward code integration with multiple microcontrollers. Make sure you have installed the DHT library in your Arduino IDE by going to Sketch \u0026gt; Include Library \u0026gt; Manage Libraries and search for the DHT sensor library from Adafruit.\nOnce installed, the setup code looks like the following:\n/* Libraries */ #include \u0026lt;DHT.h\u0026gt; /* Sensor configuration variables*/ #define DHT_PIN 2 // The data pin is connected to the ESP01 GPIO2 pin #define DHT_TYPE DHT22 /* Globals */ DHT dht(DHT_PIN, DHT_TYPE); void setup() { // Start the sensor communication dht.begin(); } void loop() { // Let\u0026#39;s give the little fella some breathing room delay(1000); float temperature = dht.readTemperature(); float humidity = dht.readHumidity(); // Wi-Fi and POST request code } And this is the minimum working code example which allows ESP01 to request data from DHT22.\nUpload\u003e Upload # After the code is added and the compilation process is successful, the upload process can start. Make sure that the proper board (Generic ESP8266 Module) and communication port are selected, hit the upload button and wait for the upload process to finish.\nConclusion\u003e Conclusion # This post covers the wiring and sensor data acquisition part which is the essential part for our weather station in order to obtain any environmental data. In the next posts, I will write about the server (design decisions and the code), dockerize the server environment, how to make HTTP requests with ESP01 and store the sensor data into a database.\nIf youâre interested how the full working example looks like, you can have a look here.\nStay tuned and thanks for reading!\n","date":"26 March 2023","permalink":"/posts/weatherstation_part1/","section":"Posts","summary":"How to set-up and connect a small weather measuring station by using the ESP8266 microcontroller and DHT22 temperature and humidity sensor.","title":"Weather station - It's alive!"},{"content":" Software engineer | Masters degree in CS | Croatia With experience in bringing software solutions to the table, I have mostly worked on projects in both the automotive and medical industries. My passion lies in working with low-level technologies such as C and C++, where I also gained most of my programming experience. I have also developed a keen interest in developing and optimizing build systems by utilizing tools like CMake and Bazel to streamline the build and development process. Also, love to work on improving CI processes to have the most optimal (resource-wise) workflow.\nThe drive for self-improvement has led me to expand my skill set further, and have also undertaken the task of learning Golang and Rust which allows me to resolve problems from a different perspective and develop single software solutions with various technologies. In my free time, I indulge in my creative side by designing and printing 3D models, and tinker on various home and open-source projects which include a broad set of software and hardware components in order to achieve unusual solutions in a most efficient way.\nFeel free to contact me if you want to learn more about my projects or have any questions.\n","date":"1 January 0001","permalink":"/about/","section":"Digital Sandbox","summary":"Software engineer | Masters degree in CS | Croatia With experience in bringing software solutions to the table, I have mostly worked on projects in both the automotive and medical industries.","title":"About me"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":" Projects that I was working on or are still in progress. ","date":"1 January 0001","permalink":"/portfolio/","section":"Portfolio","summary":"Projects that I was working on or are still in progress.","title":"Portfolio"}]